#lang concolic-hop/lang
;; this file generated by convert-soft-contract.rkt using r-file.sch as input
(require concolic-hop/ctc concolic-hop/lib concolic-hop/convert-it)
(define-lump L (0 'closed) (1 'ignore) (2 'init) (3 'opened))
(define-concolic-test
 r-file
 #:inputs
 (Amb integer)
 (|B(0 close_ close (->s (->s any/s lump/s lump/s) dont-care/s) (-> (-> any/c STATE/C STATE/C) dont-care/c))|
  (->s
   (->s
    (or/s
     (->s integer integer)
     (list/s boolean (list-of integer))
     integer
     boolean)
    (->s integer integer))
   boolean))
 (|B(1 closeit close (->s (->s lump/s lump/s) dont-care/s) (-> (-> STATE/C (one-of/c (quote closed) (quote ignore))) dont-care/c))|
  (->s (->s integer integer) boolean))
 (|B(2 f f (->s (->s any/s any/s lump/s any/s) dont-care/s) (-> (-> any/c any/c STATE/C any/c) dont-care/c))|
  (->s
   (->s
    (or/s
     (->s integer integer)
     (list/s boolean (list-of integer))
     integer
     boolean)
    (->s
     (or/s
      (->s integer integer)
      (list/s boolean (list-of integer))
      integer
      boolean)
     (->s
      integer
      (or/s
       (->s integer integer)
       (list/s boolean (list-of integer))
       integer
       boolean))))
   boolean))
 (|B(3 g g (->s (->s integer any/s lump/s any/s) dont-care/s) (-> (-> integer? any/c STATE/C any/c) dont-care/c))|
  (->s
   (->s
    integer
    (->s
     (or/s
      (->s integer integer)
      (list/s boolean (list-of integer))
      integer
      boolean)
     (->s
      integer
      (or/s
       (->s integer integer)
       (list/s boolean (list-of integer))
       integer
       boolean))))
   boolean))
 (|B(4 loop utils (->s (->s any/s integer) dont-care/s) (-> (-> any/c (λ (_) #f)) dont-care/c))|
  (->s
   (->s
    (or/s
     (->s integer integer)
     (list/s boolean (list-of integer))
     integer
     boolean)
    integer)
   boolean))
 (|B(5 main main (->s (->s integer integer any/s) dont-care/s) (-> (-> integer? integer? any/c) dont-care/c))|
  (->s
   (->s
    integer
    (->s
     integer
     (or/s
      (->s integer integer)
      (list/s boolean (list-of integer))
      integer
      boolean)))
   boolean))
 (|B(6 next next (->s (->s lump/s lump/s) dont-care/s) (-> (-> STATE/C STATE/C) dont-care/c))|
  (->s (->s integer integer) boolean))
 (|B(7 read_ read (->s (->s any/s lump/s lump/s) dont-care/s) (-> (-> any/c STATE/C STATE/C) dont-care/c))|
  (->s
   (->s
    (or/s
     (->s integer integer)
     (list/s boolean (list-of integer))
     integer
     boolean)
    (->s integer integer))
   boolean))
 (|B(8 readit read (->s (->s lump/s lump/s) dont-care/s) (-> (-> (one-of/c (quote opened) (quote ignore)) (one-of/c (quote opened))) dont-care/c))|
  (->s (->s integer integer) boolean))
 #:prop
 (prop-not-exn
  (λ ()
    (define (_loop x) (_loop #f))
    (define-ctc STATE/C (one-of/c 'init 'opened 'closed 'ignore))
    (define-id-with-ctc (-> any/c (λ (_) #f)) _loop loop bug bug)
    (define (_readit st) (if (equal? 'opened st) 'opened 'ignore))
    (define (_read_ x st) (if x (_readit st) st))
    (define-id-with-ctc
     (-> (one-of/c 'opened 'ignore) (one-of/c 'opened))
     _readit
     readit
     bug
     bug)
    (define-id-with-ctc (-> any/c STATE/C STATE/C) _read_ read_ bug bug)
    (define (_closeit st)
      (cond
       ((equal? 'opened st) 'closed)
       ((equal? 'ignore st) 'ignore)
       (else (begin (loop #f) 0))))
    (define (_close_ x st) (if x (_closeit st) st))
    (define-id-with-ctc
     (-> STATE/C (one-of/c 'closed 'ignore))
     _closeit
     closeit
     bug
     bug)
    (define-id-with-ctc (-> any/c STATE/C STATE/C) _close_ close_ bug bug)
    (define (_f x y st)
      (begin (close_ y (close_ x st)) (_f x y (read_ y (read_ x st)))))
    (define-id-with-ctc (-> any/c any/c STATE/C any/c) _f f bug bug)
    (define (_next st) (if (equal? 'init st) 'opened 'ignore))
    (define-id-with-ctc (-> STATE/C STATE/C) _next next bug bug)
    (define (_g b3 x st) (if (> b3 0) (f x #t (next st)) (f x #f st)))
    (define-id-with-ctc (-> integer? any/c STATE/C any/c) _g g bug bug)
    (define (_main b2 b3)
      (begin (if (> b2 0) (g b3 #t 'opened) (g b3 #f 'init)) 'unit))
    (define-id-with-ctc (-> integer? integer? any/c) _main main bug bug)
    (cond
     ((= Amb 0)
      ((apply-ctc
        (-> (-> any/c STATE/C STATE/C) dont-care/c)
        (convert-it
         |B(0 close_ close (->s (->s any/s lump/s lump/s) dont-care/s) (-> (-> any/c STATE/C STATE/C) dont-care/c))|
         (->s (->s any/s lump/s lump/s) dont-care/s)
         L)
        bad-input
        no-blame
        |wrap close_|)
       close_))
     ((= Amb 1)
      ((apply-ctc
        (-> (-> STATE/C (one-of/c 'closed 'ignore)) dont-care/c)
        (convert-it
         |B(1 closeit close (->s (->s lump/s lump/s) dont-care/s) (-> (-> STATE/C (one-of/c (quote closed) (quote ignore))) dont-care/c))|
         (->s (->s lump/s lump/s) dont-care/s)
         L)
        bad-input
        no-blame
        |wrap closeit|)
       closeit))
     ((= Amb 2)
      ((apply-ctc
        (-> (-> any/c any/c STATE/C any/c) dont-care/c)
        (convert-it
         |B(2 f f (->s (->s any/s any/s lump/s any/s) dont-care/s) (-> (-> any/c any/c STATE/C any/c) dont-care/c))|
         (->s (->s any/s any/s lump/s any/s) dont-care/s)
         L)
        bad-input
        no-blame
        |wrap f|)
       f))
     ((= Amb 3)
      ((apply-ctc
        (-> (-> integer? any/c STATE/C any/c) dont-care/c)
        (convert-it
         |B(3 g g (->s (->s integer any/s lump/s any/s) dont-care/s) (-> (-> integer? any/c STATE/C any/c) dont-care/c))|
         (->s (->s integer any/s lump/s any/s) dont-care/s)
         L)
        bad-input
        no-blame
        |wrap g|)
       g))
     ((= Amb 4)
      ((apply-ctc
        (-> (-> any/c (λ (_) #f)) dont-care/c)
        (convert-it
         |B(4 loop utils (->s (->s any/s integer) dont-care/s) (-> (-> any/c (λ (_) #f)) dont-care/c))|
         (->s (->s any/s integer) dont-care/s)
         L)
        bad-input
        no-blame
        |wrap loop|)
       loop))
     ((= Amb 5)
      ((apply-ctc
        (-> (-> integer? integer? any/c) dont-care/c)
        (convert-it
         |B(5 main main (->s (->s integer integer any/s) dont-care/s) (-> (-> integer? integer? any/c) dont-care/c))|
         (->s (->s integer integer any/s) dont-care/s)
         L)
        bad-input
        no-blame
        |wrap main|)
       main))
     ((= Amb 6)
      ((apply-ctc
        (-> (-> STATE/C STATE/C) dont-care/c)
        (convert-it
         |B(6 next next (->s (->s lump/s lump/s) dont-care/s) (-> (-> STATE/C STATE/C) dont-care/c))|
         (->s (->s lump/s lump/s) dont-care/s)
         L)
        bad-input
        no-blame
        |wrap next|)
       next))
     ((= Amb 7)
      ((apply-ctc
        (-> (-> any/c STATE/C STATE/C) dont-care/c)
        (convert-it
         |B(7 read_ read (->s (->s any/s lump/s lump/s) dont-care/s) (-> (-> any/c STATE/C STATE/C) dont-care/c))|
         (->s (->s any/s lump/s lump/s) dont-care/s)
         L)
        bad-input
        no-blame
        |wrap read_|)
       read_))
     (else
      ((apply-ctc
        (-> (-> (one-of/c 'opened 'ignore) (one-of/c 'opened)) dont-care/c)
        (convert-it
         |B(8 readit read (->s (->s lump/s lump/s) dont-care/s) (-> (-> (one-of/c (quote opened) (quote ignore)) (one-of/c (quote opened))) dont-care/c))|
         (->s (->s lump/s lump/s) dont-care/s)
         L)
        bad-input
        no-blame
        |wrap readit|)
       readit))))))
(define (counterexample)
  (define test-result
    (concolic-test r-file #:all? #f #:timeout 5 #:statistics? #t))
  (define witness (list-ref test-result 0))
  (define stats (list-ref test-result 1))
  (vector
   (concretize-input r-file witness)
   '('closed 'ignore 'init 'opened)
   `#hash((solve-count . ,(concolic-statistics-solve-count stats))
          (solve-real-nongc-time
           .
           ,(concolic-statistics-solve-real-nongc-time stats))
          (test-count . ,(concolic-statistics-test-count stats)))))
(provide counterexample (rename-out (r-file test-property)))
(module+ main (counterexample))
