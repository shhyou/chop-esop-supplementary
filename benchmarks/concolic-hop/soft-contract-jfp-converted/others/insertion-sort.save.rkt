#lang concolic-hop/lang
;; this file generated by convert-soft-contract.rkt using insertion-sort.sch as input
(require concolic-hop/ctc concolic-hop/lib concolic-hop/convert-it)
(define-lump L)
(define-concolic-test
 insertion-sort
 #:inputs
 (|M(opaque insert (->s integer (list-of integer) (list-of integer)))|
  (->s integer (->s (list-of integer) (list-of integer))))
 (|M(opaque ne-sorted? (->s (list-of integer) boolean))|
  (->s (list-of integer) boolean))
 (|•(0 (list-of any/s))|
  (list-of (or/s (->s integer integer) (list-of integer) integer boolean)))
 #:prop
 (prop-not-exn
  (λ ()
    (define _insert
      (convert-it
       |M(opaque insert (->s integer (list-of integer) (list-of integer)))|
       (->s integer (list-of integer) (list-of integer))
       L))
    (define _ne-sorted?
      (convert-it
       |M(opaque ne-sorted? (->s (list-of integer) boolean))|
       (->s (list-of integer) boolean)
       L))
    (define ne-sorted?
      (apply-ctc
       (-> (non-empty-listof integer?) boolean?)
       _ne-sorted?
       bad-input
       bug
       ne-sorted?))
    (define-ctc
     SORTED/C
     (or/c empty? (and/c (non-empty-listof integer?) ne-sorted?)))
    (define insert
      (apply-ctc
       (-> integer? SORTED/C (and/c (non-empty-listof integer?) ne-sorted?))
       _insert
       bad-input
       bug
       insert))
    (define (_sort xs) (_foldl insert xs empty))
    (define (_foldl f l b) (if (empty? l) b (_foldl f (cdr l) (f (car l) b))))
    (define sort
      (apply-ctc
       (->i
        ((l (listof any/c)))
        (res
         (l)
         (and/c SORTED/C (λ (r) (if (empty? l) (empty? r) (cons? r))))))
       _sort
       bug
       bug
       sort))
    (sort
     (apply-ctc
      (listof any/c)
      (convert-it |•(0 (list-of any/s))| (list-of any/s) L)
      bad-input
      no-blame
      |argument of sort|)))))
(define counterexample (vector (concretize-input insertion-sort (concolic-test insertion-sort #:all? #f)) (quote ())))
(provide counterexample)
