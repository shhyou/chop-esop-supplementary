#lang concolic-hop/lang
;; this file generated by convert-soft-contract.rkt using braun-tree.sch as input
(require concolic-hop/ctc concolic-hop/lib concolic-hop/convert-it)
(define-lump L)
(define-concolic-test
 braun-tree
 #:inputs
 (Amb integer)
 (|B(0 braun-tree? tree (->s (->s any/s boolean) integer))|
  (->s
   (->s (or/s (->s integer integer) (list-of integer) integer boolean) boolean)
   integer))
 (|B(1 insert tree (->s (->s (or/s boolean (struct/s node any/s (or/s boolean (struct/s node any/s none/s none/s)) (or/s boolean (struct/s node any/s none/s none/s)))) any/s (or/s boolean (struct/s node any/s (or/s boolean (struct/s node any/s none/s none/s)) (or/s boolean (struct/s node any/s none/s none/s))))) integer))|
  (->s
   (->s
    (or/s
     boolean
     (list/s
      integer
      (or/s (->s integer integer) (list-of integer) integer boolean)
      (or/s
       boolean
       (list/s
        integer
        (or/s (->s integer integer) (list-of integer) integer boolean)
        boolean
        boolean))
      (or/s
       boolean
       (list/s
        integer
        (or/s (->s integer integer) (list-of integer) integer boolean)
        boolean
        boolean))))
    (->s
     (or/s (->s integer integer) (list-of integer) integer boolean)
     (or/s
      boolean
      (list/s
       integer
       (or/s (->s integer integer) (list-of integer) integer boolean)
       (or/s
        boolean
        (list/s
         integer
         (or/s (->s integer integer) (list-of integer) integer boolean)
         boolean
         boolean))
       (or/s
        boolean
        (list/s
         integer
         (or/s (->s integer integer) (list-of integer) integer boolean)
         boolean
         boolean))))))
   integer))
 #:prop
 (prop-not-exn
  (Î» ()
    (struct node (v l r))
    (define (_braun-tree? x)
      (or (false? x)
          (and (node? x)
               (_braun-tree? (node-l x))
               (_braun-tree? (node-r x))
               (let ((l (_size (node-l x))) (r (_size (node-r x))))
                 (or (= l r) (= l (add1 r)))))))
    (define (_size x)
      (if (node? x) (add1 (+ (_size (node-l x)) (_size (node-r x)))) 0))
    (define (_insert bt x)
      (if (node? bt)
        (node (node-v bt) (_insert (node-l bt) x) (node-r bt))
        (node x #f #f)))
    (define braun-tree?
      (apply-ctc (-> any/c boolean?) _braun-tree? bug bug braun-tree?))
    (define insert
      (apply-ctc (-> braun-tree? any/c braun-tree?) _insert bug bug insert))
    (cond
     ((= Amb 0)
      ((apply-ctc
        (-> (-> any/c boolean?) integer?)
        (convert-it
         |B(0 braun-tree? tree (->s (->s any/s boolean) integer))|
         (->s (->s any/s boolean) integer)
         L)
        bad-input
        no-blame
        |wrap braun-tree?|)
       braun-tree?))
     (else
      ((apply-ctc
        (-> (-> braun-tree? any/c braun-tree?) integer?)
        (convert-it
         |B(1 insert tree (->s (->s (or/s boolean (struct/s node any/s (or/s boolean (struct/s node any/s none/s none/s)) (or/s boolean (struct/s node any/s none/s none/s)))) any/s (or/s boolean (struct/s node any/s (or/s boolean (struct/s node any/s none/s none/s)) (or/s boolean (struct/s node any/s none/s none/s))))) integer))|
         (->s
          (->s
           (or/s
            boolean
            (struct/s
             node
             any/s
             (or/s boolean (struct/s node any/s none/s none/s))
             (or/s boolean (struct/s node any/s none/s none/s))))
           any/s
           (or/s
            boolean
            (struct/s
             node
             any/s
             (or/s boolean (struct/s node any/s none/s none/s))
             (or/s boolean (struct/s node any/s none/s none/s)))))
          integer)
         L)
        bad-input
        no-blame
        |wrap insert|)
       insert))))))
(define counterexample (vector (concretize-input braun-tree (concolic-test braun-tree #:all? #f)) (quote ())))
(provide counterexample)
